<!DOCTYPE html>

<html>
<head>
  <title>client.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="client.html">
                client.js
              </a>
            
              
              <a class="source" href="index.html">
                index.js
              </a>
            
              
              <a class="source" href="server.html">
                server.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>client.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-comment">/*
 * Vibe Client
 * http://vibe-project.github.io/projects/vibe-protocol/
 * 
 * Copyright 2014 The Vibe Project 
 * Licensed under the Apache License, Version 2.0
 * http://www.apache.org/licenses/LICENSE-2.0
 */</span>
<span class="hljs-keyword">var</span> events      = <span class="hljs-built_in">require</span>(<span class="hljs-string">"events"</span>);
<span class="hljs-keyword">var</span> url         = <span class="hljs-built_in">require</span>(<span class="hljs-string">"url"</span>);
<span class="hljs-keyword">var</span> crypto      = <span class="hljs-built_in">require</span>(<span class="hljs-string">"crypto"</span>);
<span class="hljs-keyword">var</span> WebSocket   = <span class="hljs-built_in">require</span>(<span class="hljs-string">"ws"</span>);
<span class="hljs-keyword">var</span> http        = <span class="hljs-built_in">require</span>(<span class="hljs-string">"http"</span>);
<span class="hljs-keyword">var</span> EventSource = <span class="hljs-built_in">require</span>(<span class="hljs-string">"eventsource"</span>);

http.globalAgent.maxSockets = <span class="hljs-literal">Infinity</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>This module is exposed to the parent module’s <code>client</code> as a constructor of
client.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-built_in">module</span>.exports = client;</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>A client instance to be returned by this function is a factory to create
socket to connect to the server. It is expected to use HTTP and WebSocket
client implementation that are standardized in <a href="http://tools.ietf.org/html/rfc2616">RFC
2616</a> and <a href="http://tools.ietf.org/html/rfc6455">RFC
6455</a>, respectively.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">client</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">var</span> client = {};
    client.open = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(uri, options)</span> </span>{
        <span class="hljs-keyword">return</span> socket(uri, options);
    };
    <span class="hljs-keyword">return</span> client;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>An URI specified in <a href="http://tools.ietf.org/html/rfc3986">RFC 3986</a> is the
complete path to the vibe server endpoint. The protocol uses only the query
string to pass information to interact with the server so be aware of
reserved parameters.</p>
<p>The followings parameters are always included to the query string:</p>
<ul>
<li><code>id</code>: a socket id in the form of UUID.</li>
<li><code>_</code>: a random string for anti-caching.</li>
</ul>
<p>Additionally if the method is <code>GET</code>, the followings are attached as well.  </p>
<ul>
<li><code>when</code>: a goal of request.</li>
</ul>
<p>The <code>when</code> can be one of the followings and according to that value,
additional params are attached to query string.</p>
<ul>
<li><code>open</code>: to establish a connection.<ul>
<li><code>transport</code>: a transport id being used. It can be one of the followings:<ul>
<li><code>ws</code>: WebSocket.</li>
<li><code>sse</code>: Server-Sent Events.</li>
<li><code>streamxhr</code>: XMLHttpRequest Streaming.</li>
<li><code>streamxdr</code>: XDomainRequest Streaming. </li>
<li><code>streamiframe</code>: Hidden Iframe Streaming. </li>
<li><code>longpollajax</code>: AJAX Long Polling. </li>
<li><code>longpollxdr</code>: XDomainRequest Long Polling. </li>
<li><code>longpolljsonp</code>: JSONP Long Polling. </li>
</ul>
</li>
<li><code>callback</code>: a callback name used in <code>longpolljsonp</code> transport.</li>
</ul>
</li>
<li><code>poll</code>: to supply long polling transport with a new HTTP exchange.<ul>
<li><code>lastEventIds</code>: a comma-separated value of an id of the client-received 
events in the preceding response.</li>
</ul>
</li>
<li><code>abort</code>: to notify the server of disconnection of HTTP transports.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildURI</span><span class="hljs-params">(uri, params)</span> </span>{
    <span class="hljs-keyword">var</span> urlObj = url.parse(uri, <span class="hljs-literal">true</span>);
    urlObj.query = urlObj.query || {};
    urlObj.query.id = params.id;
    urlObj.query._ = crypto.randomBytes(<span class="hljs-number">3</span>).toString(<span class="hljs-string">"hex"</span>);
    
    <span class="hljs-keyword">if</span> (params.when) {
        urlObj.query.when = params.when;
        <span class="hljs-keyword">switch</span> (params.when) {
        <span class="hljs-keyword">case</span> <span class="hljs-string">"open"</span>:
            urlObj.query.transport = params.transport;
            <span class="hljs-keyword">if</span> (params.callback) {
                urlObj.query.callback = params.callback;
            }
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-string">"poll"</span>:
            urlObj.query.lastEventIds = params.lastEventIds;
            <span class="hljs-keyword">break</span>;
        }
    }
    
    <span class="hljs-keyword">delete</span> urlObj.search;
    <span class="hljs-keyword">return</span> url.format(urlObj);
}</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>A socket is an interface to exchange event between the two endpoints and
expected to be public for developers to create vibe application. The event
is serialized to and deseriazlied from JSON specified in
<a href="http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf">ECMA-404</a>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">socket</span><span class="hljs-params">(uri, options)</span> </span>{
    <span class="hljs-keyword">var</span> socket = <span class="hljs-keyword">new</span> events.EventEmitter();
    <span class="hljs-keyword">var</span> transport;</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Most options to establish a connection come from handshaking.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    options = options || {};</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Perform a handshake request to negotiate the protocol</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    http.get(buildURI(uri, {when: <span class="hljs-string">"handshake"</span>}))</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>If any error is encountered, fires the <code>close</code> event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    .on(<span class="hljs-string">"error"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> </span>{
        socket.emit(<span class="hljs-string">"error"</span>, error);
    })
    .on(<span class="hljs-string">"response"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(res)</span> </span>{
        <span class="hljs-keyword">var</span> body = <span class="hljs-string">""</span>;
        res.on(<span class="hljs-string">"error"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> </span>{
            socket.emit(<span class="hljs-string">"error"</span>, error);
        })
        .on(<span class="hljs-string">"data"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(chunk)</span> </span>{
            body += chunk;
        })
        .on(<span class="hljs-string">"end"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>The result of handshaking is a form of JSON and contains
information to establish a connection.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> result = <span class="hljs-built_in">JSON</span>.parse(body);</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>A newly issued id for this socket.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            socket.id = result.id;</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p><code>transport</code> a user assigned explicitly is prioritized than the
result of handshaking, but it’s usually for testing so not
desired.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (!options.transport) {</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Picks out the supported ones by this client.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">var</span> candidates = result.transports.filter(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(name)</span> </span>{
                    <span class="hljs-keyword">return</span> name <span class="hljs-keyword">in</span> transports;
                });</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>If nothing is available, it’s not possible to connect to the
server. Fire the <code>close</code> event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (candidates.length === <span class="hljs-number">0</span>) {
                    socket.emit(<span class="hljs-string">"error"</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"notransport"</span>));
                    <span class="hljs-keyword">return</span>;
                }</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Choose the first one among transport both client and server
support.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                options.transport = candidates[<span class="hljs-number">0</span>];
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p><code>heartbeat</code> and <code>_heartbeat</code> should be set through only
handshaking. However, <code>_heartbeat</code> is usually for testing so it
may be not passed from the server. The default value is <code>5000</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            options.heartbeat = result.heartbeat;
            options._heartbeat = result._heartbeat || <span class="hljs-number">5000</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>According to the transport option, create the transport and
connect to the server.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            transport = transports[options.transport](uri, {id: socket.id});</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>For testing, assigns a real uri used in establishing a connection
to socket</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            socket.uri = transport.uri;</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Delegates transport’s <code>open</code> and <code>close</code> events to socket.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            transport.on(<span class="hljs-string">"open"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
                socket.emit(<span class="hljs-string">"open"</span>);
            });
            transport.on(<span class="hljs-string">"error"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> </span>{
                socket.emit(<span class="hljs-string">"error"</span>, error);
            });
            transport.on(<span class="hljs-string">"close"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
                socket.emit(<span class="hljs-string">"close"</span>);
            });</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>When the underlying transport has received a message from the
server.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            transport.on(<span class="hljs-string">"message"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(text)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Converts JSON to an event object.</p>
<p>It should have the following properties:</p>
<ul>
<li><code>id: string</code>: an event identifier.</li>
<li><code>type: string</code>: an event type.</li>
<li><code>data: any</code>: an event data.</li>
</ul>
<p>If the client implements <code>reply</code> extension, the following
properties should be considered as well.</p>
<ul>
<li><code>reply: boolean</code>: true if this event requires the reply.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">var</span> event = <span class="hljs-built_in">JSON</span>.parse(text);</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>If the server sends a plain event, dispatch it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (!event.reply) {
                    socket.emit(event.type, event.data);</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>This is how to implement <code>reply</code> extension. An event handler
for the corresponding event will receive reply controller as
2nd argument. It calls the server’s resolved or rejected
callback by sending <code>reply</code> event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>The latch prevents double reply.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="hljs-keyword">var</span> latch;
                    socket.emit(event.type, event.data, {
                        resolve: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value)</span> </span>{
                            <span class="hljs-keyword">if</span> (!latch) {
                                latch = <span class="hljs-literal">true</span>;
                                socket.send(<span class="hljs-string">"reply"</span>, {id: event.id, data: value, exception: <span class="hljs-literal">false</span>});
                            }
                        },
                        reject: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(reason)</span> </span>{
                             <span class="hljs-keyword">if</span> (!latch) {
                                 latch = <span class="hljs-literal">true</span>;
                                 socket.send(<span class="hljs-string">"reply"</span>, {id: event.id, data: reason, exception: <span class="hljs-literal">true</span>});
                             }
                        }
                    });
                }
            });
        });
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>An id for event. It should be unique among events to be sent to the
server and has nothing to do with one the server sent.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> eventId = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>A map for reply callbacks for <code>reply</code> extension.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> callbacks = {};
    socket.send = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(type, data, resolved, rejected)</span> </span>{
        <span class="hljs-keyword">if</span> (!transport) {
            socket.emit(<span class="hljs-string">"error"</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"notopened"</span>));
            <span class="hljs-keyword">return</span>;
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>It should have the following properties:</p>
<ul>
<li><code>id: string</code>: an event identifier.</li>
<li><code>type: string</code>: an event type.</li>
<li><code>data: any</code>: an event data.</li>
</ul>
<p>If the client implements <code>reply</code> extension, the following properties
should be available as well.</p>
<ul>
<li><code>reply: boolean</code>: true if this event requires the reply.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> event = {
            id: <span class="hljs-string">""</span> + eventId++, 
            type: type, 
            data: data, 
            reply: resolved != <span class="hljs-literal">null</span> || rejected != <span class="hljs-literal">null</span>
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>For <code>reply</code> extension, stores resolved and rejected callbacks if they
are given.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (event.reply) {
            callbacks[event.id] = {resolved: resolved, rejected: rejected};
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>Convert the event to JSON and sends it through the transport.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        transport.send(<span class="hljs-built_in">JSON</span>.stringify(event));
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>For <code>reply</code> extension, on the <code>reply</code> event, executes the stored reply
callbacks with data.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    socket.on(<span class="hljs-string">"reply"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(reply)</span> </span>{
        <span class="hljs-keyword">if</span> (reply.id <span class="hljs-keyword">in</span> callbacks) {
            <span class="hljs-keyword">var</span> cbs = callbacks[reply.id];
            <span class="hljs-keyword">var</span> fn = reply.exception ? cbs.rejected : cbs.resolved;
            <span class="hljs-keyword">if</span> (fn) {
                fn.call(<span class="hljs-keyword">this</span>, reply.data);
            }
            <span class="hljs-keyword">delete</span> callbacks[reply.id];
        }
    });
    socket.close = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>If a user closes a socket before finishing handshaking, the transport
would be <code>null</code>. Then, fire the <code>close</code> event. If not, the transport
will fire the <code>close</code> event and it will propagate to this socket.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (transport) {
            transport.close();
        } <span class="hljs-keyword">else</span> {
            socket.emit(<span class="hljs-string">"close"</span>);
        }
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>Starts the heartbeat handshakes on <code>open</code> event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    socket.on(<span class="hljs-string">"open"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">var</span> heartbeatTimer;
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setHeartbeatTimer</span><span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>Sets a timer to send an <code>heartbeat</code> event after
<code>heartbeat - _heartbeat</code> miliseconds.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            heartbeatTimer = setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
                socket.send(<span class="hljs-string">"heartbeat"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>Sets a timer to close the socket if the server doesn’t
respond in the <code>_heartbeat</code> interval.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                heartbeatTimer = setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
                    socket.emit(<span class="hljs-string">"error"</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"heartbeat"</span>));
                    socket.close();
                }, options._heartbeat);
            }, options.heartbeat - options._heartbeat);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>If the server echoes back the sent <code>heartbeat</code> event, clears the
timer and set it again.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        socket.on(<span class="hljs-string">"heartbeat"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
            clearTimeout(heartbeatTimer);
            setHeartbeatTimer();
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>The heartbeat handshake should be stopped on <code>close</code> event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        socket.on(<span class="hljs-string">"close"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
            clearTimeout(heartbeatTimer);
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>Starts the heartbeat.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        setHeartbeatTimer();
    });
    <span class="hljs-keyword">return</span> socket;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>A transport is used to establish a persistent connection, send data, receive
data and close the connection and is expected to be private for user not to
access.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> transports = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>A base transport for every transport.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>transports.base = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(uri, params)</span> </span>{
    <span class="hljs-keyword">var</span> transport = <span class="hljs-keyword">new</span> events.EventEmitter();
    transport.close = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>Aborts the real connection. It should be implemented by others.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        transport.abort();</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>Server may not detect disconnection for some reason though the
connection is based on WebSocket. To prevent idle connections,
notifies the server of disconnection of this connection.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        http.get(buildURI(uri, {id: params.id, when: <span class="hljs-string">"abort"</span>}));
    };
    <span class="hljs-keyword">return</span> transport;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>WebSocket is a protocol designed for a full-duplex communications over a TCP
connection. However, it’s not always available for various reason.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>transports.ws = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(uri, params)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>Builds an URI to open changing the protocol from http to ws and connects
to the server over WebSocket protocol.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> u = buildURI(uri, {id: params.id, when: <span class="hljs-string">"open"</span>, transport: <span class="hljs-string">"ws"</span>}).replace(<span class="hljs-regexp">/^http/</span>, <span class="hljs-string">"ws"</span>);
    <span class="hljs-keyword">var</span> ws = <span class="hljs-keyword">new</span> WebSocket(u);
    <span class="hljs-keyword">var</span> transport = transports.base(uri, params);
    transport.uri = u;</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>Simply delegates WebSocket’s events to transport and transport’s
behaviors to WebSocket.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    ws.onopen = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        transport.emit(<span class="hljs-string">"open"</span>);
    };
    ws.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> </span>{
        transport.emit(<span class="hljs-string">"error"</span>, error);
    };
    ws.onclose = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        transport.emit(<span class="hljs-string">"close"</span>);
    };
    ws.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> </span>{
        transport.emit(<span class="hljs-string">"message"</span>, event.data);
    };
    transport.send = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(data)</span> </span>{
        ws.send(data);
    };
    transport.abort = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        ws.close();
    };
    <span class="hljs-keyword">return</span> transport;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>A base transport for the following HTTP transports.</p>
<ul>
<li><strong>HTTP Streaming</strong>: the client performs a HTTP persistent
connection and watches changes in response text and the server prints chunk
as data to the connection.</li>
<li><strong> HTTP Long Polling</strong>: the client performs a HTTP persistent connection
and the server ends the connection with data. Then, the client receives it
and performs a request again and again.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>transports.httpbase = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(uri, params)</span> </span>{
    <span class="hljs-keyword">var</span> transport = transports.base(uri, params);</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>A flag to check if this transport is opened.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> opened = <span class="hljs-literal">false</span>;
    transport.on(<span class="hljs-string">"open"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        opened = <span class="hljs-literal">true</span>;
    });
    transport.on(<span class="hljs-string">"close"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        opened = <span class="hljs-literal">false</span>;
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>A persistent connection established by transport over HTTP protocol is
only for the server to send something to the client. For the client to
send something to the server, issues a request through <code>POST</code> method.
And its content type header should be <code>text/plain; charset=utf-8</code> and the
final data should be prefixed with <code>data=</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    transport.send = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(data)</span> </span>{
        <span class="hljs-keyword">var</span> reqOpts = url.parse(buildURI(uri, {id: params.id}));
        reqOpts.method = <span class="hljs-string">"POST"</span>;
        reqOpts.headers = {<span class="hljs-string">"content-type"</span>: <span class="hljs-string">"text/plain; charset=utf-8"</span>};
        http.request(reqOpts).on(<span class="hljs-string">"error"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>Try again as long as this transport is available if sending event
to the server fails.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">if</span> (opened) {
                transport.send(data);
            }
        })
        .end(<span class="hljs-string">"data="</span> + data);
    };
    <span class="hljs-keyword">return</span> transport;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>The <a href="http://www.w3.org/TR/eventsource/">Server-Sent Events</a>
specified by W3C is yet another HTTP streaming technique.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>transports.sse = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(uri, params)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>Builds an URI to open and connects to the server over HTTP protocol.
EventSource uses <code>GET</code> method.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> u = buildURI(uri, {id: params.id, when: <span class="hljs-string">"open"</span>, transport: <span class="hljs-string">"sse"</span>});
    <span class="hljs-keyword">var</span> es = <span class="hljs-keyword">new</span> EventSource(u);
    <span class="hljs-keyword">var</span> transport = transports.httpbase(uri, params);
    transport.uri = u;</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>Simply delegates EventSource’s events to transport and transport’s
behaviors to EventSource.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    es.onopen = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> </span>{
        transport.emit(<span class="hljs-string">"open"</span>);
    };
    es.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> </span>{
        transport.emit(<span class="hljs-string">"message"</span>, event.data);
    };
    es.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        es.close();</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>Even though the event name is ‘error’ but it’s fired even in normal
closure. Assumes there was no error.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        transport.emit(<span class="hljs-string">"close"</span>);
    };
    transport.abort = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>Closes the EventSource.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        es.close();</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>EventSource doesn’t notify of disconnection. Therefore fires the
<code>close</code> event immediately.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        transport.emit(<span class="hljs-string">"close"</span>);
    };
    <span class="hljs-keyword">return</span> transport;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>Their difference is which host object initiates and progresses a connection
in browser. Therefore, client not running on browser like Java
client don’t have to implement them. (If there is no reliable <code>sse</code>
implementation, you can implement <code>streamxhr</code> using a plain HTTP client)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>[<span class="hljs-string">"streamxhr"</span>, <span class="hljs-string">"streamxdr"</span>, <span class="hljs-string">"streamiframe"</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(tpName)</span> </span>{
    transports[tpName] = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(uri, params)</span> </span>{
        <span class="hljs-keyword">var</span> req;
        <span class="hljs-keyword">var</span> transport = transports.httpbase(uri, params);</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>Performs a persistent HTTP connection via <code>GET</code> method.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> u = buildURI(uri, {id: params.id, when: <span class="hljs-string">"open"</span>, transport: tpName});
        transport.uri = u;
        req = http.get(u)</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>If any error is encountered, fires the <code>error</code> event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        .on(<span class="hljs-string">"error"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> </span>{
            transport.emit(<span class="hljs-string">"error"</span>, error);
        })</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>Technically the <code>open</code> event should be fired by the first chunk,
padding, but non-browser client doesn’t need to do that because
it can detect when the response headers have been received.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        .on(<span class="hljs-string">"response"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(res)</span> </span>{
            transport.emit(<span class="hljs-string">"open"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>Every chunk may be a single event, multiple events or a fragment
of a single event. This buffer helps handle fragments.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">var</span> buffer = <span class="hljs-string">""</span>;
            res.on(<span class="hljs-string">"error"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> </span>{
                transport.emit(<span class="hljs-string">"error"</span>, error);
            })</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>Chunks are formatted according to the <a href="http://www.w3.org/TR/eventsource/#event-stream-interpretation">event stream
format</a>.
However, you don’t need to know that. A single event starts with
‘data: ‘ and ends with <code>\n\n</code>. That’s all you need to know.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            .on(<span class="hljs-string">"data"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(chunk)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>Strips off the left padding of the chunk that appears in the
first chunk.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                chunk = chunk.toString().replace(<span class="hljs-regexp">/^\s+/</span>, <span class="hljs-string">""</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>If the chunk consists of only whitespace characters that is 
the first chunk padding in the above, there is nothing to do.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> (!chunk) {
                    <span class="hljs-keyword">return</span>;
                }</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>Let’s think of a series of the following chunks:</p>
<ul>
<li><code>&quot;data: {}\n\ndata: {}\n\n&quot;</code></li>
<li><code>&quot;data: {}\n\ndata: {&quot;</code></li>
<li><code>&quot;}\n\ndata:{&quot;</code></li>
<li><code>&quot;..&quot;</code></li>
<li><code>&quot;.}&quot;</code></li>
<li><code>&quot;\n\ndata: {}\n\n&quot;</code></li>
</ul>
<p>It looks not easy to handle. So let’s concatenate buffer 
and chunk. Here the buffer is a string after last <code>\n\n</code> 
of the concatenation.</p>
<ul>
<li><code>&quot;&quot;</code> + <code>&quot;data: {}\n\ndata: {}\n\n&quot;</code></li>
<li><code>&quot;&quot;</code> + <code>&quot;data: {}\n\ndata: {&quot;</code></li>
<li><code>&quot;data: {&quot;</code> + <code>&quot;}\n\ndata:{&quot;</code></li>
<li><code>&quot;data: {&quot;</code> + <code>&quot;..&quot;</code></li>
<li><code>&quot;data: {..&quot;</code> + <code>&quot;.}&quot;</code></li>
<li><code>&quot;data: {...}&quot;</code> + <code>&quot;\n\ndata: {}\n\n&quot;</code></li>
</ul>

            </div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p>Let’s split the concatenation by <code>\n\n</code>. </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">var</span> i;
                <span class="hljs-keyword">var</span> lines = (buffer + chunk).split(<span class="hljs-string">"\n\n"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>Lines except the last consist of a complete data starting 
with ‘data: ‘ Unwraps ‘data: ‘ and fires a message event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; lines.length - <span class="hljs-number">1</span>; i++) {
                    transport.emit(<span class="hljs-string">"message"</span>, lines[i].substring(<span class="hljs-string">"data: "</span>.length));
                }</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>The last element is a fragment of a data. Assigns it to
buffer.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                buffer = lines[lines.length - <span class="hljs-number">1</span>];
            })
            .on(<span class="hljs-string">"end"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
                transport.emit(<span class="hljs-string">"close"</span>);
            });
        });
        transport.abort = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p>Aborts the current request. The rest of work, firing the <code>close</code>
event, will be done by <code>res</code>‘s <code>end</code> event handler.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            req.abort();
        };
        <span class="hljs-keyword">return</span> transport;
    };
});</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>Their difference is which host object initiates and progresses a connection
in browser. Therefore, client not running on browser like Java client don’t
have to implement <code>longpollxdr</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>[<span class="hljs-string">"longpollajax"</span>, <span class="hljs-string">"longpollxdr"</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(tpName)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <p>In long polling, a pseudo-connection consisting of disposable HTTP 
exchanges pretends to be a persistent connection.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    transports[tpName] = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(uri, params)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>The current holding request.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> req;
        <span class="hljs-keyword">var</span> transport = transports.httpbase(uri, params);</pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p>The first request is to open and subsequent requests are to poll. 
All they use <code>GET</code> method.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> u = buildURI(uri, {id: params.id, when: <span class="hljs-string">"open"</span>, transport: tpName});
        transport.uri = u;
        req = http.get(u)</pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <p>If any error is encountered during the request, that means the
server is not available. So fires the <code>error</code> event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        .on(<span class="hljs-string">"error"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> </span>{
            transport.emit(<span class="hljs-string">"error"</span>, error);
        })</pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <p>If the first request is completed normally since the server is 
available, start to poll and fire the open event. There must be 
no idle time between the poll. Starting poll request is always
prior to dispatching events.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        .on(<span class="hljs-string">"response"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <p>For the first time, starts with empty array.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            poll([]);</pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <p>The poll request is just started so fires the <code>open</code> event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            transport.emit(<span class="hljs-string">"open"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p>From the second request, <code>when</code> is <code>poll</code> and <code>lastEventIds</code>
is needed that is comma-separated values of event ids in the 
preceding request’s response.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">poll</span><span class="hljs-params">(lastEventIds)</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <p>FYI, <code>[&quot;x&quot;, &quot;y&quot;, &quot;z&quot;].join(&quot;,&quot;)</code> gives <code>&quot;x,y,z&quot;</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                req = http.get(buildURI(uri, {id: params.id, when: <span class="hljs-string">"poll"</span>, lastEventIds: lastEventIds.join(<span class="hljs-string">","</span>)}))
                .on(<span class="hljs-string">"error"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> </span>{
                    transport.emit(<span class="hljs-string">"error"</span>, error);
                })</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p>If the server responds to this request, determine whether 
the intention of response is to send event or to close by 
reading body.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                .on(<span class="hljs-string">"response"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(res)</span> </span>{
                    <span class="hljs-keyword">var</span> body = <span class="hljs-string">""</span>;
                    res.on(<span class="hljs-string">"error"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> </span>{
                        transport.emit(<span class="hljs-string">"error"</span>, error);
                    })
                    .on(<span class="hljs-string">"data"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(chunk)</span> </span>{
                        body += chunk;
                    })
                    .on(<span class="hljs-string">"end"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
                        <span class="hljs-keyword">if</span> (body) {</pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <p>To prepare the next request, identify events in 
the response and collect their ids.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                            <span class="hljs-keyword">var</span> eventIds = [];
                            <span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">JSON</span>.parse(body);</pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <p>If the parsed object is an array, it contains 
events that the client couldn’t receive before, 
which may happen within only long polling. FYI,
<code>[{id:1},{id:2},{id:3}].map(function(e) {return
e.id;})</code> gives <code>[1,2,3]</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(obj)) {
                                eventIds = obj.map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> </span>{
                                     <span class="hljs-keyword">return</span> event.id;
                                });</pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <p>Otherwise, it’s a single event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                            } <span class="hljs-keyword">else</span> {
                                eventIds = [obj.id];
                            }</pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <p>Sends a poll request again before to fire events.
Again this order is important.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                            poll(eventIds);</pre></div></div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <p>Fires those event one by one. A transport is 
supposed to receive a single stringified event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(obj)) {
                                obj.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> </span>{
                                     transport.emit(<span class="hljs-string">"message"</span>, <span class="hljs-built_in">JSON</span>.stringify(event));
                                });
                            } <span class="hljs-keyword">else</span> {
                                transport.emit(<span class="hljs-string">"message"</span>, body);
                            }</pre></div></div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <p>Absent body indicates the server closed the socket.
Accordingly fires the <code>close</code> event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                        } <span class="hljs-keyword">else</span> {
                            transport.emit(<span class="hljs-string">"close"</span>);
                        }
                    });
                });
            }
        });</pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <p>Aborts the current request.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        transport.abort = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <p>Node fires a ‘socket hang up’ error if there was no response from the
server, which is a general case in long polling. But it’s not error
here so remove all error handlers.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            req.removeAllListeners(<span class="hljs-string">"error"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <p>However, it means disconnection and <code>res</code>‘s <code>end</code> handler doesn’t 
exist. Therefore, fire the <code>close</code> event on <code>req</code>‘s <code>error</code> event.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            req.on(<span class="hljs-string">"error"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
                transport.emit(<span class="hljs-string">"close"</span>);
            });
            req.abort();
        };
        <span class="hljs-keyword">return</span> transport;
    };
});</pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <p>Except request’s callback param, response’s content-type header and how to
parse its body, <code>longpolljsonp</code> and <code>longpollajax</code> are all the same.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>transports.longpolljsonp = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(uri, params)</span> </span>{
    <span class="hljs-keyword">var</span> req;
    <span class="hljs-keyword">var</span> transport = transports.httpbase(uri, params);</pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <p>Adds the callback param. In browser response body can’t be controlled so
it should be unique in the document.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> u = buildURI(uri, {id: params.id, when: <span class="hljs-string">"open"</span>, transport: <span class="hljs-string">"longpolljsonp"</span>, callback: <span class="hljs-string">"dayoff"</span>});
    transport.uri = u;
    req = http.get(u)
    .on(<span class="hljs-string">"error"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> </span>{
        transport.emit(<span class="hljs-string">"error"</span>, error);
    })
    .on(<span class="hljs-string">"response"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        poll([]);
        transport.emit(<span class="hljs-string">"open"</span>);
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">poll</span><span class="hljs-params">(lastEventIds)</span> </span>{
            req = http.get(buildURI(uri, {id: params.id, when: <span class="hljs-string">"poll"</span>, lastEventIds: lastEventIds.join(<span class="hljs-string">","</span>)}))
            .on(<span class="hljs-string">"error"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> </span>{
                transport.emit(<span class="hljs-string">"error"</span>, error);
            })
            .on(<span class="hljs-string">"response"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(res)</span> </span>{
                <span class="hljs-keyword">var</span> body = <span class="hljs-string">""</span>;
                res.on(<span class="hljs-string">"error"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(error)</span> </span>{
                    transport.emit(<span class="hljs-string">"error"</span>, error);
                })
                .on(<span class="hljs-string">"data"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(chunk)</span> </span>{
                    body += chunk;
                })
                .on(<span class="hljs-string">"end"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
                    <span class="hljs-keyword">if</span> (body) {</pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <p>The returned body is a JavaScript code executing 
the callback with data. In browser, it will be 
executed immediately. Here we can manipulate the 
body so retrieve the real data by stripping 
function call experession and unescpaing it as JSON.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                        body = <span class="hljs-built_in">JSON</span>.parse(body.match(<span class="hljs-regexp">/^dayoff\((.*)\);$/</span>)[<span class="hljs-number">1</span>]);
                        <span class="hljs-keyword">var</span> eventIds = [];
                        <span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">JSON</span>.parse(body);
                        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(obj)) {
                            eventIds = obj.map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> </span>{
                                <span class="hljs-keyword">return</span> event.id;
                            });
                        } <span class="hljs-keyword">else</span> {
                            eventIds = [obj.id];
                        }
                        poll(eventIds);
                        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(obj)) {
                            obj.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> </span>{
                                transport.emit(<span class="hljs-string">"message"</span>, <span class="hljs-built_in">JSON</span>.stringify(event));
                            });
                        } <span class="hljs-keyword">else</span> {
                            transport.emit(<span class="hljs-string">"message"</span>, body);
                        }
                    } <span class="hljs-keyword">else</span> {
                        transport.emit(<span class="hljs-string">"close"</span>);
                    }
                });
            });
        }
    });
    transport.abort = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
        req.removeAllListeners(<span class="hljs-string">"error"</span>);
        req.on(<span class="hljs-string">"error"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
            transport.emit(<span class="hljs-string">"close"</span>);
        });
        req.abort();
    };
    <span class="hljs-keyword">return</span> transport;
};</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
